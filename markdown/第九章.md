# <center> 第九章:顺序容器

---

---

## 9.1:顺序容器概述

容器就是以些特定类型对象的集合,**顺序容器**(sequential container)为程序员提供了控制元素存储和访问顺序的能力.这种顺序不依赖于元素的值,而是与元素加入容器时的位置相对应.与之相对的.
标准库提供了以下的顺序容器,他们都支持顺序访问,不过在随机访问和增添删除中有各自的折中方案
![顺序容器](image/顺序容器.png)

### 9.1.1 各自的折中方案

string 和 vector 在内存中是连续分布的,因此随机访问很快,但是插入元素就相对较慢了(因为如果要插入一个元素,则后面的元素都要移动).
相对应的,list 和 forward_list 插入元素很快,但是不能随机访问,有时为了访问一个元素,要遍历整个容器,而且他们的内存开销也比 vector 和 string 大.
deque(双端队列)也能随机访问(可能也慢),但是在开头和尾部插入删除却很快.array 是 c++11 新的类型,与内置的数组类似,大小固定,但是 array 更加安全易用.
对于 forward_list 而言,其创造是为了能够达到和手写的单向列表相同的性能,并且由于保存和计算单向列表的大小会造成很多开销,因此 forward_list 没有 size()函数.而其他的容器都保证了 size()是一个快速的操作.

### 9.1.2 选择容器的原则

1. 除非有很好的理由选择其他容器，否则应使用 vector。
2. 如果你的程序有很多小的元素，且空间的额外开销很重要，则不要使用 list 或 forward_list。
3. 如果程序要求随机访问元素，应使用 vector 或 deque。
4. 如果程序要求在容器的中间插入或删除元素，应使用 list 或 forward_list。如果程序需要在头尾位置插入或删除元素，但不会在中间位置进行插入或删除操作，则使用 deque。
5. 如果程序只有在读取输入时才需要在容器中间位置插入元素随后需要随机访问元素，则

- 首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 vector 追加数据，然后再调用标准库的 sort 函数（我们将在 10.2.3 节介绍 sort（第 343 页)）来重排容器中的元素，从而避免在中间位置添加元素。
- 如果必须在中间位置插入元素，考虑在输入阶段使用 list，一旦输入完成，将 list 中的内容拷贝到一个 vector 中。
  如果既要随机访问又要插入元素,则比较二者当中谁的使用机会比较多.如果相差无几,则需要单独测试不同容器的效率 xc
  如果不确定,可以只使用 vector 和 list 进行公共操作,使用迭代器而不是下标来避免随机访问.

## 9.2 容器库概览

### 9.2.1 容器库

除了顺序容器,标准库还提供了关联容器和无序容器.
相对应的是容器操作,所有容器有共同的操作,一类容器有独特的操作,而小部分容器有专属的操作.
一般来说,每个容器都定义在和它们同名的头文件里.而容器都是类模板,大多数容器都需要提供额外的信息(类型)

```cpp
list<string> list1;//保存string的双向链表
deque<vector<double> >//保存类型为double的向量的双端队列
```

### 9.2.1 对容器保存的元素的限制

顺序容器几乎可以保存所有类型,一个容器的元素是另一个容器的定义和一般的没区别(但是有的编译器在两个右尖括号直接需要空格 > > ).
虽然可以在容器中保存几乎任何类型,但某些容器操作对元素类型有其自己的特殊要求.我们可以为不支持特定操作需求的类型定义容器，但这种情况下就只能使用那些没有特殊要求的容器操作了。
例如，顺序容器构造函数的一个版本接受容器大小参数,它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数

```cpp
//假定noDefault是一个没有默认构造函数的类型
vector<noDefault> v1(10, init);//正确:提供了元素初始化器
vector<noDefault> v2(10);//错误:必须提供一个元素初始化器
```
